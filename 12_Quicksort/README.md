# Quick SortQuicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Developed by Tony Hoare in 1959,[1] with his work published in 1961,[2] it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.[3]Quicksort is a comparison sort, meaning that it can sort items of any type for which a "less-than" relation (formally, a total order) is defined. In efficient implementations it is not a stable sort, meaning that the relative order of equal sort items is not preserved. Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.Mathematical analysis of quicksort shows that, on average, the algorithm takes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare.## AdvantagesQuicksort is an in-place sort that needs no temporary memory.Typically, quicksort is faster in practice than other  algorithms, because its inner loop can be efficiently implemented on most architectures.Quicksort tends to make excellent usage of the memory hierarchy like virtual memory or caches. It is well suited to modern computer architectures.Quicksort can be easily parallelized due to its divide-and-conquer nature ## DisadvantagesThis algorithm may swap the elements with equal comparison keys (it is not a stable sort).Simpler algorithms like insertion sort perform better for the small (10 elements or about) data sets. The advanced implementations automatically switch into simpler alternative algorithm if the data set is small enough.## ImplementationQuicksort uses "divide and conquer strategy" to divide a list into two sub-lists.The steps are:Pick an element, called a pivot, from the list (somewhere from the middle).Reorder the list so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.Recursively sort the sub-list of lesser elements and the sub-list of greater elements.The base case of the recursion are lists of size zero or one, which are always sorted.The stage 2, reordering, can be implemented in various ways.### Pseudo CodeQuicksort Sort:```Quicksort(A,p,r) {    if (p < r) {       q <- Partition(A,p,r)       Quicksort(A,p,q)       Quicksort(A,q+1,r)    }}Partition(A,p,r)    x <- A[p]    i <- p-1    j <- r+1    while (True) {        repeat            j <- j-1        until (A[j] <= x)        repeat            i <- i+1        until (A[i] >= x)        if (i A[j]        else             return(j)    }}```![Quick Sort animation](quick_sort_partition_animation.gif)## Exercise[QuickSort Sorting  - Taken from Hackerrank](https://www.hackerrank.com/challenges/quicksort2)